<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Fonts Showcase</title>
    
    <!-- Favicon with different colors -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%234285F4'/><text x='50' y='60' font-family='Arial, sans-serif' font-size='50' fill='white' text-anchor='middle' font-weight='bold'>G</text></svg>" type="image/svg+xml">
    
    <!-- External CSS file -->
    <link rel="stylesheet" href="styles.css">
    

    
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üé® Google Fonts Showcase</h1>
            <p class="subtitle">Browse and preview beautiful Google Fonts</p>
        </header>

        <div class="sticky-controls">
            <div class="font-counter" id="font-counter"><span id="category-name">All Fonts</span>: <span id="category-count">0</span> fonts</div>
            <div class="search-container">
                <div class="search-input-wrapper">
                    <input type="text" id="font-search" placeholder="üîç Search fonts by name..." 
                           title="Type to search, press ESC to clear, click outside to reset">
                    <button id="clear-search" title="Clear search (or press ESC)">√ó</button>
                </div>
            </div>

            <div class="font-categories">
                <button class="category-btn active" data-category="all">All Fonts</button>
                <button class="category-btn" data-category="sans-serif">Sans Serif</button>
                <button class="category-btn" data-category="serif">Serif</button>
                <button class="category-btn" data-category="display">Display</button>
                <button class="category-btn" data-category="cursive">Cursive</button>
                <button class="category-btn" data-category="monospace">Monospace</button>
                <button class="category-btn" data-category="caps">CAPS</button>
                <button class="category-btn" data-category="favorites">‚ù§Ô∏è Favs</button>
                <button class="theme-toggle-btn" id="theme-toggle">üåì</button>
            </div>

            <div class="preview-text-input">
                <div style="position: relative;">
                    <input type="text" id="preview-text" placeholder="Enter text to preview..."
                        value="Gloire √† l'√©t√© br√ªlant, √† l'hiver glac√© : voil√† deux saisons bien diff√©rentes ! √ätre 123 √âl√©phants, ou 456 √àve ?">
                    <div class="preview-text-controls">
                        <button class="preview-text-control-btn" id="increase-font-size" title="Increase font size">+</button>
                        <button class="preview-text-control-btn" id="reset-preview-font" title="Reset font">√ó</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="pagination-top-container">
            <!-- Top pagination will be inserted here by JavaScript -->
        </div>
        <div class="fonts-grid" id="fonts-container">
            <div class="loading">Loading fonts...</div>
        </div>
    </div>

    <script>
        // Global variables
        let allFonts = [];
        let currentCategory = 'all';
        let previewText = "Gloire √† l'√©t√© br√ªlant, √† l'hiver glac√© : voil√† deux saisons bien diff√©rentes ! √ätre 123 √âl√©phants, ou 456 √àve ?";
        let currentPage = 1;
        const fontsPerPage = 21; // Number of fonts to display per page (7x3 grid = 21)
        const favorites = new Set(); // Store favorite fonts
        let isDarkTheme = false; // Track dark theme state

        // DOM elements (will be initialized when DOM is ready)
        let fontsContainer, themeToggleBtn, fontSearch, previewTextInput, categoryButtons, clearSearchBtn;

        // Add beautiful background with 4 large cursive corner letters and pattern
        function addBackgroundLetters() {
            console.log('Adding beautiful background pattern...');
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const body = document.body;
            const patternContainer = document.createElement('div');
            patternContainer.className = 'background-letters';
            
            // Add 4 large cursive characters in corners (mix of letters and numbers)
            const allCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const cornerCharacters = [];
            
            // Generate 4 random characters (ensure at least 2 are numbers)
            for (let i = 0; i < 4; i++) {
                if (i < 2 || Math.random() < 0.5) {
                    // First two are numbers, or 50% chance for others
                    const numbers = '0123456789';
                    cornerCharacters.push(numbers[Math.floor(Math.random() * numbers.length)]);
                } else {
                    // Letter
                    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                    cornerCharacters.push(letters[Math.floor(Math.random() * letters.length)]);
                }
            }
            
            const cornerPositions = [
                {top: 5, left: 3, size: 200, font: 'cursive'},
                {top: 8, right: 5, size: 250, font: 'cursive'},
                {bottom: 15, left: 2, size: 220, font: 'cursive'},
                {bottom: 10, right: 4, size: 180, font: 'cursive'}
            ];
            
            cornerCharacters.forEach((char, index) => {
                const cornerElement = document.createElement('div');
                cornerElement.className = 'background-letter corner-letter';
                cornerElement.textContent = char;
                // Use different elegant fonts for each corner
                const elegantFonts = [
                    'cursive',
                    'fantasy',
                    'cursive',
                    'fantasy'
                ];
                cornerElement.style.fontFamily = elegantFonts[index];
                
                // Add some font variation with CSS properties
                if (index === 0) {
                    cornerElement.style.fontStyle = 'italic';
                } else if (index === 1) {
                    cornerElement.style.fontWeight = '600';
                } else if (index === 2) {
                    cornerElement.style.fontStyle = 'italic';
                    cornerElement.style.fontWeight = '600';
                }
                cornerElement.style.fontSize = cornerPositions[index].size + 'px';
                cornerElement.style.top = cornerPositions[index].top + '%';
                cornerElement.style.left = cornerPositions[index].left + '%';
                cornerElement.style.right = cornerPositions[index].right + '%';
                cornerElement.style.bottom = cornerPositions[index].bottom + '%';
                cornerElement.style.transform = `rotate(${Math.random() * 15 - 7.5}deg)`;
                
                // Apply theme-appropriate styles from the start
                const isDarkTheme = document.body.classList.contains('dark-theme');
                if (isDarkTheme) {
                    // Dark theme - reduced opacity for better readability
                    cornerElement.style.opacity = '0.3';
                    cornerElement.style.color = 'rgba(150, 150, 150, 0.2)';
                } else {
                    // Light theme - original opacity
                    cornerElement.style.opacity = '0.6';
                    cornerElement.style.color = 'rgba(220, 220, 220, 0.6)';
                }
                
                patternContainer.appendChild(cornerElement);
            });
            
            // Add pattern of smaller letters and numbers
            const patternCount = 30;
            
            for (let i = 0; i < patternCount; i++) {
                const charElement = document.createElement('div');
                charElement.className = 'background-letter pattern-letter';
                
                // Random character
                const randomChar = characters[Math.floor(Math.random() * characters.length)];
                // Make numbers slightly more likely (60% letters, 40% numbers)
                if (Math.random() < 0.4) {
                    const numbers = '0123456789';
                    charElement.textContent = numbers[Math.floor(Math.random() * numbers.length)];
                } else {
                    charElement.textContent = randomChar;
                }
                
                // Random positioning (avoid corners)
                const top = 15 + Math.random() * 70; // 15% to 85% from top
                const left = 10 + Math.random() * 80; // 10% to 90% from left
                const size = 30 + Math.random() * 80; // 30px to 110px
                const rotation = Math.random() * 40 - 20; // -20¬∞ to +20¬∞
                
                charElement.style.top = top + '%';
                charElement.style.left = left + '%';
                charElement.style.fontSize = size + 'px';
                charElement.style.transform = `rotate(${rotation}deg)`;
                
                // Apply theme-appropriate styles from the start
                const isDarkTheme = document.body.classList.contains('dark-theme');
                if (isDarkTheme) {
                    // Dark theme - reduced opacity for better readability
                    charElement.style.opacity = '0.2';
                    charElement.style.color = 'rgba(180, 180, 180, 0.15)';
                } else {
                    // Light theme - original opacity
                    charElement.style.opacity = Math.random() * 0.2 + 0.1; // 0.1 to 0.3 opacity
                    charElement.style.color = 'rgba(200, 200, 200, 0.6)';
                }
                
                patternContainer.appendChild(charElement);
            }
            
            body.insertBefore(patternContainer, body.firstChild);
            console.log('Beautiful background pattern added!');
        }

        // Call the function when page loads
        document.addEventListener('DOMContentLoaded', addBackgroundLetters);
        
        // Also call it immediately in case DOM is already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            addBackgroundLetters();
        }

        // Initialize the app
        async function init() {
            try {
                // Initialize DOM elements
                fontsContainer = document.getElementById('fonts-container');
                themeToggleBtn = document.getElementById('theme-toggle');
                fontSearch = document.getElementById('font-search');
                previewTextInput = document.getElementById('preview-text');
                categoryButtons = document.querySelectorAll('.category-btn');
                clearSearchBtn = document.getElementById('clear-search');

                // Load font data
                const response = await fetch('google-fonts.json');
                if (!response.ok) {
                    throw new Error('Failed to load font data');
                }

                allFonts = await response.json();

                // Convert font data to array format
                allFonts = Object.entries(allFonts).map(([name, data]) => ({
                    name,
                    category: data.category === 'handwriting' ? 'cursive' : data.category,
                    subsets: data.subsets || [],
                    variants: data.variants || {}
                }));

                // Filter fonts with Latin subset
                allFonts = allFonts.filter(font => font.subsets.includes('latin'));

                // Display fonts
                displayFonts();

                // Set up event listeners
                setupEventListeners();

            } catch (error) {
                console.error('Error loading fonts:', error);
                fontsContainer.innerHTML = `<div class="no-results">Error loading fonts. Please try again later.</div>`;
            }
        }

        function setupEventListeners() {
            // Search functionality
            fontSearch.addEventListener('input', () => {
                displayFonts();
                // Show/hide clear button based on search input
                if (clearSearchBtn) {
                    clearSearchBtn.style.display = fontSearch.value.length > 0 ? 'block' : 'none';
                }
            });

            // Click on search box - position cursor after category name
            fontSearch.addEventListener('click', () => {
                // Ensure the search box has focus
                fontSearch.focus();
                
                // Only add prefix if search box is empty
                if (fontSearch.value === '') {
                    // Get category name from global variable
                    let categoryName = '';
                    if (currentCategory === 'caps') {
                        categoryName = 'CAPS Fonts';
                    } else if (currentCategory === 'all') {
                        categoryName = 'All Fonts';
                    } else if (currentCategory === 'favorites') {
                        categoryName = 'Favorites';
                    } else {
                        // Capitalize first letter for other categories
                        categoryName = currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1);
                    }
                    
                    // Set search value with descriptive prefix (consistent for all categories)
                    fontSearch.value = 'Search ' + categoryName + ': ';
                    // Position cursor at the end
                    fontSearch.selectionStart = fontSearch.selectionEnd = fontSearch.value.length;
                    
                    // Show the clear button since we now have content
                    if (clearSearchBtn) {
                        clearSearchBtn.style.display = 'block';
                    }
                }
            });

            // Reset search box when clicking outside (blur event)
            fontSearch.addEventListener('blur', () => {
                // Always reset search box to empty when clicking outside
                // This provides the cleanest UX by completely clearing the field
                fontSearch.value = '';
                
                // Hide clear button
                if (clearSearchBtn) {
                    clearSearchBtn.style.display = 'none';
                }
            });
            
            // Add Escape key support for search reset
            fontSearch.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' || event.keyCode === 27) {
                    // Reset search on Escape key
                    fontSearch.value = '';
                    
                    // Hide clear button
                    if (clearSearchBtn) {
                        clearSearchBtn.style.display = 'none';
                    }
                    
                    // Trigger search to show all fonts
                    fontSearch.dispatchEvent(new Event('input'));
                    
                    // Prevent default Escape behavior
                    event.preventDefault();
                    event.stopPropagation();
                }
            });
            
            // Clear search button functionality
            if (clearSearchBtn) {
                clearSearchBtn.addEventListener('click', () => {
                    fontSearch.value = '';
                    fontSearch.focus();
                    displayFonts();
                    clearSearchBtn.style.display = 'none';
                });
            }

            // Preview text functionality
            previewTextInput.addEventListener('input', () => {
                previewText = previewTextInput.value;
                updateAllPreviews();
            });

            // Theme toggle button
            themeToggleBtn.addEventListener('click', () => {
                toggleTheme();
            });

            // Font card clicks - change preview text font
            document.addEventListener('click', (e) => {
                const fontCard = e.target.closest('.font-card');
                if (fontCard) {
                    // Don't change preview font if clicking on Copy CSS button, View on Google button, or card size button
                    const copyCSSButton = e.target.closest('.btn-primary');
                    const viewGoogleButton = e.target.closest('.btn-secondary');
                    const cardSizeButton = e.target.closest('.card-size-increase-btn');
                    
                    if (!copyCSSButton && !viewGoogleButton && !cardSizeButton) {
                        const fontName = fontCard.dataset.fontName;
                        const fontCategory = fontCard.dataset.fontCategory;
                        changePreviewFont(fontName, fontCategory);
                    }
                }
            });

            // Font size increase button
            const increaseFontSizeBtn = document.getElementById('increase-font-size');
            if (increaseFontSizeBtn) {
                increaseFontSizeBtn.addEventListener('click', () => {
                    increasePreviewFontSize();
                });
            }

            // Reset preview font button
            const resetPreviewFontBtn = document.getElementById('reset-preview-font');
            if (resetPreviewFontBtn) {
                resetPreviewFontBtn.addEventListener('click', () => {
                    resetPreviewFont();
                });
            }

            // Category buttons
            categoryButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons
                    categoryButtons.forEach(btn => btn.classList.remove('active'));

                    // Add active class to clicked button
                    button.classList.add('active');

                    // Update current category
                    currentCategory = button.dataset.category;

                    // Clear search box when switching categories (reset to placeholder)
                    fontSearch.value = '';
                    
                    // Hide clear button since search is now empty
                    if (clearSearchBtn) {
                        clearSearchBtn.style.display = 'none';
                    }

                    // Display fonts for selected category
                    displayFonts();
                });
            });
            
            // Favorite heart clicks
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('favorite-heart')) {
                    const fontName = e.target.dataset.fontName;
                    
                    // Toggle favorite status
                    if (favorites.has(fontName)) {
                        favorites.delete(fontName);
                        e.target.classList.remove('favorited');
                    } else {
                        favorites.add(fontName);
                        e.target.classList.add('favorited');
                    }
                    
                    // Save to localStorage
                    saveFavorites();
                    
                    // Show favorites button immediately
                    const favoritesBtn = document.querySelector('.category-btn[data-category="favorites"]');
                    if (favoritesBtn) {
                        if (favorites.size > 0) {
                            favoritesBtn.style.display = 'inline-block';
                        } else {
                            favoritesBtn.style.display = 'none';
                        }
                    }
                    
                    // Update favorites count if favorites category is active
                    if (currentCategory === 'favorites') {
                        displayFonts();
                    }
                }
            });
        }

        function toggleTheme() {
            isDarkTheme = !isDarkTheme;
            document.body.classList.toggle('dark-theme');
            
            // Update button icon based on current theme
            themeToggleBtn.textContent = isDarkTheme ? '‚òÄÔ∏è' : 'üåì';
            
            // Save theme preference to localStorage
            localStorage.setItem('themePreference', isDarkTheme ? 'dark' : 'light');
            
            // Update background letters opacity for dark theme
            updateBackgroundLettersForTheme();
        }
        
        function updateBackgroundLettersForTheme() {
            const isDark = document.body.classList.contains('dark-theme');
            const cornerLetters = document.querySelectorAll('.corner-letter');
            const patternLetters = document.querySelectorAll('.pattern-letter');
            
            if (isDark) {
                // Dark theme - significantly reduce opacity for better readability
                cornerLetters.forEach(letter => {
                    letter.style.opacity = '0.3';
                    letter.style.color = 'rgba(150, 150, 150, 0.2)';
                });
                
                patternLetters.forEach(letter => {
                    letter.style.opacity = '0.2';
                    letter.style.color = 'rgba(180, 180, 180, 0.15)';
                });
            } else {
                // Light theme - restore original opacity
                cornerLetters.forEach(letter => {
                    letter.style.opacity = '0.6';
                    letter.style.color = 'rgba(220, 220, 220, 0.6)';
                });
                
                patternLetters.forEach(letter => {
                    letter.style.opacity = Math.random() * 0.2 + 0.1;
                    letter.style.color = 'rgba(200, 200, 200, 0.6)';
                });
            }
        }

        function loadThemePreference() {
            const savedTheme = localStorage.getItem('themePreference');
            if (savedTheme === 'dark') {
                isDarkTheme = true;
                document.body.classList.add('dark-theme');
                themeToggleBtn.textContent = '‚òÄÔ∏è';
                
                // Update background letters for dark theme
                updateBackgroundLettersForTheme();
            }
        }

        function changePreviewFont(fontName, fontCategory) {
            const previewTextElement = document.getElementById('preview-text');
            if (previewTextElement) {
                // Store the current font selection
                previewTextElement.dataset.currentFont = fontName;
                previewTextElement.dataset.currentFontCategory = fontCategory;
                
                // Use appropriate size array based on font category
                currentSizeArray = previewFontSizes[fontCategory] || previewFontSizes['default'];
                
                // Update the preview text styling to show it's using the selected font
                previewTextElement.style.fontFamily = `'${fontName}', ${getFallbackFont(fontCategory)}`;
                previewTextElement.style.fontSize = currentSizeArray[0] + 'px';
                previewTextElement.style.fontWeight = 'normal';
                
                // Reset size tracking to default
                currentSizeIndex = 0;
                currentFontSize = currentSizeArray[currentSizeIndex];
                
                // Add a visual indicator
                previewTextElement.classList.add('using-card-font');
                
                // Show a temporary notification
                showFontSelectionNotification(fontName);
            }
        }

        function showFontSelectionNotification(fontName) {
            // Remove any existing notification
            const existingNotification = document.querySelector('.font-selection-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification
            const notification = document.createElement('div');
            notification.className = 'font-selection-notification';
            notification.textContent = `Preview text now uses: ${fontName}`;
            
            // Style the notification
            notification.style.position = 'fixed';
            notification.style.bottom = '20px';
            notification.style.right = '20px';
            notification.style.padding = '12px 20px';
            notification.style.backgroundColor = '#4285F4';
            notification.style.color = 'white';
            notification.style.borderRadius = '25px';
            notification.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
            notification.style.zIndex = '1000';
            notification.style.fontSize = '14px';
            notification.style.fontWeight = '500';
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(20px)';
            notification.style.transition = 'opacity 0.3s, transform 0.3s';
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function resetPreviewFont() {
            const previewTextElement = document.getElementById('preview-text');
            if (previewTextElement) {
                // Remove the custom font styling
                previewTextElement.style.fontFamily = '';
                previewTextElement.style.fontSize = '';
                previewTextElement.style.fontWeight = '';
                
                // Remove the visual indicator class
                previewTextElement.classList.remove('using-card-font');
                
                // Clear the stored font data
                delete previewTextElement.dataset.currentFont;
                delete previewTextElement.dataset.currentFontCategory;
                
                // Reset font size tracking to default
                currentFontSize = 16;
                currentSizeIndex = 0;
                currentSizeArray = previewFontSizes['default']; // Reset to default size array
                
                // Show reset notification
                showFontResetNotification();
            }
        }

        function showFontResetNotification() {
            // Remove any existing notification
            const existingNotification = document.querySelector('.font-selection-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification
            const notification = document.createElement('div');
            notification.className = 'font-selection-notification';
            notification.textContent = 'Preview text reset to default font';
            
            // Style the notification (already styled via CSS class)
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // Font size management for preview text
        // Different size ranges for different font categories (same as card text)
        const previewFontSizes = {
            'cursive': [20, 22, 24, 28, 32], // Cursive fonts: start at 20px, go up to 32px
            'default': [16, 18, 20, 22, 24, 28, 32] // Other fonts: standard sizes up to 32px
        };
        let currentFontSize = 16; // Default size when using card font
        let currentSizeArray = previewFontSizes['default']; // Default size array
        let currentSizeIndex = 0; // Current index in size array
        
        // Font size management for card text
        // Different size ranges for different font categories
        const cardFontSizes = {
            'cursive': [20, 22, 24, 28, 32], // Cursive fonts: start at 20px, go up to 32px
            'default': [16, 18, 20, 22, 24, 28, 32] // Other fonts: standard sizes up to 32px
        };
        const cardSizeMap = new Map(); // Track individual card sizes

        function increasePreviewFontSize() {
            const previewTextElement = document.getElementById('preview-text');
            if (previewTextElement && previewTextElement.classList.contains('using-card-font')) {
                // Get the current font category
                const fontCategory = previewTextElement.dataset.currentFontCategory || 'default';
                
                // Use appropriate size array based on font category
                currentSizeArray = previewFontSizes[fontCategory] || previewFontSizes['default'];
                
                // Cycle through font sizes
                currentSizeIndex = (currentSizeIndex + 1) % currentSizeArray.length;
                currentFontSize = currentSizeArray[currentSizeIndex];
                
                previewTextElement.style.fontSize = currentFontSize + 'px';
                
                // Update button active state
                updateSizeButtonStates();
                
                // Show notification
                showFontSizeNotification(currentFontSize);
            }
        }

        function updateSizeButtonStates() {
            const increaseBtn = document.getElementById('increase-font-size');
            if (increaseBtn) {
                // Add active class to show current size
                increaseBtn.classList.add('active');
                
                // Remove active class after a short delay
                setTimeout(() => {
                    increaseBtn.classList.remove('active');
                }, 500);
            }
        }
        
        function increaseCardTextSize(previewId) {
            const previewElement = document.getElementById(previewId);
            if (previewElement) {
                // Get the font card to determine category
                const fontCard = previewElement.closest('.font-card');
                const fontCategory = fontCard ? fontCard.dataset.fontCategory : 'default';
                
                // Use appropriate size array based on font category
                const sizeArray = cardFontSizes[fontCategory] || cardFontSizes['default'];
                
                // Get current size index for this card, default to 0
                let currentIndex = cardSizeMap.get(previewId) || 0;
                
                // Increase size index, cycle back to 0 if at the end
                currentIndex = (currentIndex + 1) % sizeArray.length;
                
                // Update the card size map
                cardSizeMap.set(previewId, currentIndex);
                
                // Apply the new font size
                const newSize = sizeArray[currentIndex];
                previewElement.style.fontSize = newSize + 'px';
                
                // Show notification
                showCardSizeNotification(newSize);
                
                // Add visual feedback to the button
                const button = event.target.closest('.card-size-increase-btn');
                if (button) {
                    button.classList.add('active');
                    setTimeout(() => {
                        button.classList.remove('active');
                    }, 300);
                }
            }
        }
        
        function showCardSizeNotification(size) {
            // Remove any existing notification
            const existingNotification = document.querySelector('.card-size-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification
            const notification = document.createElement('div');
            notification.className = 'card-size-notification';
            notification.textContent = `Card text size: ${size}px`;
            
            // Style the notification
            notification.style.position = 'fixed';
            notification.style.bottom = '20px';
            notification.style.left = '20px';
            notification.style.padding = '12px 20px';
            notification.style.backgroundColor = '#4285F4';
            notification.style.color = 'white';
            notification.style.borderRadius = '25px';
            notification.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
            notification.style.zIndex = '1000';
            notification.style.fontSize = '14px';
            notification.style.fontWeight = '500';
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(20px)';
            notification.style.transition = 'opacity 0.3s, transform 0.3s';
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove after 2 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }

        function showFontSizeNotification(size) {
            // Remove any existing notification
            const existingNotification = document.querySelector('.font-selection-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification
            const notification = document.createElement('div');
            notification.className = 'font-selection-notification';
            notification.textContent = `Font size: ${size}px`;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove after 2 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }

        function displayFonts() {
            // Show/hide favorites category based on favorites count
            const favoritesBtn = document.querySelector('.category-btn[data-category="favorites"]');
            if (favoritesBtn) {
                if (favorites.size === 0) {
                    favoritesBtn.style.display = 'none';
                } else {
                    favoritesBtn.style.display = 'inline-block'; // Ensure it's visible
                }
            }
            // Extract actual search term (remove category prefix if present)
            const fullSearchValue = fontSearch.value;
            let searchTerm = fullSearchValue.toLowerCase();
            
            // Consistent prefix handling for all categories: "Search [Category]: "
            const colonIndex = fullSearchValue.indexOf(':');
            if (colonIndex !== -1) {
                searchTerm = fullSearchValue.substring(colonIndex + 1).trim().toLowerCase();
            }

            // Show loading state
            fontsContainer.innerHTML = `<div class="loading">Loading fonts...</div>`;

            // Filter fonts
            let filteredFonts = allFonts.filter(font => {
                // Filter by category
                if (currentCategory === 'favorites') {
                    // Filter for favorite fonts
                    if (!favorites.has(font.name)) {
                        return false;
                    }
                } else if (currentCategory === 'caps') {
                    // Filter for truly all-caps fonts and SC/Caps fonts
                    // Complete list of 29 verified all-caps fonts (removed Swash Caps fonts)
                    const trulyAllCaps = [
                        'Aboreto', 'Alegreya SC', 'Alegreya Sans SC', 'Almendra SC',
                        'Amatic SC', 'Bowlby One SC', 'Bruno Ace SC',
                        'Carrois Gothic SC', 'Cormorant SC', 'Diplomata SC',
                        'Encode Sans SC', 'Graduate', 'Holtwood One SC',
                        'IM Fell DW Pica SC', 'IM Fell Double Pica SC', 'IM Fell English SC',
                        'IM Fell French Canon SC', 'IM Fell Great Primer SC', 'Marcellus SC',
                        'Mate SC', 'Monoton', 'Overlock SC', 'Patrick Hand SC', 'Playfair Display SC',
                        'Six Caps', 'Spectral SC', 'Shojumaru', 'Vollkorn SC', 'Ysabeau SC'
                    ];

                    // Also include SC (Small Caps) and Caps fonts
                    const hasSCorCaps = /\b(SC|Caps)\b/i.test(font.name);

                    // Exceptions: SC fonts and Swash Caps fonts that are NOT truly all-caps
                    const scExceptions = [
                        'Noto Sans SC', 'Noto Serif SC',
                        'Macondo Swash Caps', 'Oleo Script Swash Caps',
                        'Bilbo Swash Caps', 'Delius Swash Caps', 'Elsie Swash Caps'
                    ];

                    const isSCFont = hasSCorCaps && !scExceptions.includes(font.name);

                    return trulyAllCaps.includes(font.name) || isSCFont;
                } else if (currentCategory !== 'all' && font.category !== currentCategory) {
                    return false;
                }

                // Filter by search term
                if (searchTerm && !font.name.toLowerCase().includes(searchTerm)) {
                    return false;
                }

                return true;
            });

            // Sort filtered fonts by relevance (exact matches first, then partial matches)
            if (searchTerm) {
                filteredFonts.sort((a, b) => {
                    const aName = a.name.toLowerCase();
                    const bName = b.name.toLowerCase();
                    
                    // Calculate relevance scores
                    const aStartsWith = aName.startsWith(searchTerm) ? 2 : 0;
                    const aContains = aName.includes(searchTerm) ? 1 : 0;
                    const aScore = aStartsWith + aContains;
                    
                    const bStartsWith = bName.startsWith(searchTerm) ? 2 : 0;
                    const bContains = bName.includes(searchTerm) ? 1 : 0;
                    const bScore = bStartsWith + bContains;
                    
                    // Sort by score (descending) and then by name (ascending)
                    if (aScore !== bScore) {
                        return bScore - aScore; // Higher score first
                    }
                    return aName.localeCompare(bName); // Alphabetical for same score
                });
            }

            // Update font counter with proper format: "Category: X fonts"
            const counterElement = document.getElementById('font-counter');
            const categoryNameElement = document.getElementById('category-name');
            const categoryCountElement = document.getElementById('category-count');
            
            const categoryName = currentCategory === 'caps' ? 'CAPS Fonts' :
                               currentCategory === 'all' ? 'All Fonts' : 
                               currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1) + ' Fonts';
            
            if (categoryNameElement && categoryCountElement) {
                categoryNameElement.textContent = currentCategory === 'caps' ? 'CAPS Fonts' :
                                               currentCategory === 'all' ? 'All Fonts' : 
                                               currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1);
                categoryCountElement.textContent = filteredFonts.length;
            }
            
            // Update the counter element to show "Category: X fonts"
            if (currentCategory === 'favorites') {
                console.log('Favorites set:', Array.from(favorites));
                counterElement.innerHTML = `‚ù§Ô∏è Favorites: <strong>${filteredFonts.length}</strong> fonts`;
            } else {
                counterElement.innerHTML = `${categoryName}: <strong>${filteredFonts.length}</strong> fonts`;
            }

            // Display fonts or no results message
            if (filteredFonts.length === 0) {
                fontsContainer.innerHTML = `<div class="no-results" style="text-align: center;">No fonts found. Try a different search or category.</div>`;
                return;
            }

            // Pagination logic
            const totalPages = Math.ceil(filteredFonts.length / fontsPerPage);

            const startIndex = (currentPage - 1) * fontsPerPage;
            const endIndex = Math.min(startIndex + fontsPerPage, filteredFonts.length);
            const paginatedFonts = filteredFonts.slice(startIndex, endIndex);

            // Generate font cards with numbering
            fontsContainer.innerHTML = paginatedFonts.map((font, index) => createFontCard(font, startIndex + index + 1)).join('');

            // Add pagination controls at both top and bottom
            addPaginationControls(filteredFonts.length, totalPages, 'top');
            addPaginationControls(filteredFonts.length, totalPages, 'bottom');

            // Small delay to allow DOM to update before loading fonts
            // Update favorite hearts after displaying fonts
            updateFavoriteHearts();
            
            setTimeout(() => {
                loadFontsForPreview(paginatedFonts);
            }, 100);
        }

        function addPaginationControls(totalFonts, totalPages, position = 'bottom') {
            // Remove existing pagination controls for this position
            const existingPagination = document.querySelectorAll('.pagination');
            existingPagination.forEach(pagination => {
                if ((position === 'top' && pagination.classList.contains('pagination-top')) ||
                    (position === 'bottom' && !pagination.classList.contains('pagination-top'))) {
                    pagination.remove();
                }
            });

            // Create pagination container
            const paginationContainer = document.createElement('div');
            paginationContainer.className = 'pagination';
            if (position === 'top') {
                paginationContainer.className = 'pagination pagination-top';
            }

            // Previous button
            const prevButton = document.createElement('button');
            prevButton.textContent = '‚Üê';
            prevButton.disabled = currentPage === 1 || totalPages <= 1;
            prevButton.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    displayFonts();
                }
            });
            paginationContainer.appendChild(prevButton);

            // Page info
            const pageInfo = document.createElement('span');
            pageInfo.className = 'pagination-info';
            const startItem = (currentPage - 1) * fontsPerPage + 1;
            const endItem = Math.min(currentPage * fontsPerPage, totalFonts);
            pageInfo.innerHTML = `Page <strong>${currentPage}</strong> of ${totalPages} (${startItem}-${endItem} of <strong>${totalFonts}</strong>)`;
            paginationContainer.appendChild(pageInfo);

            // Next button
            const nextButton = document.createElement('button');
            nextButton.textContent = '‚Üí';
            nextButton.disabled = currentPage === totalPages || totalPages <= 1;
            nextButton.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    displayFonts();
                }
            });
            paginationContainer.appendChild(nextButton);

            // Add pagination to the page
            if (position === 'top') {
                const topContainer = document.getElementById('pagination-top-container');
                if (topContainer) {
                    topContainer.appendChild(paginationContainer);
                }
            } else {
                fontsContainer.parentNode.insertBefore(paginationContainer, fontsContainer.nextSibling);
            }
        }

        function createFontCard(font, index) {
            // Create a unique class name for this font
            const fontClass = `font-${font.name.toLowerCase().replace(/\s+/g, '-')}`;
            const previewId = `preview-${font.name.toLowerCase().replace(/\s+/g, '-')}`;

            // Determine preview text based on category
            const displayText = currentCategory === 'all-caps' ? previewText.toUpperCase() : previewText;

            // Check if font is truly all-caps (for CAPS category)
            const isAllCaps = checkIfAllCaps(font.name);
            const capsBadge = isAllCaps ? '<div class="caps-badge">‚úÖ CAPS</div>' : '';

            return `
                <div class="font-card ${fontClass}" data-font-name="${font.name}" data-font-category="${font.category}">
                    <div class="font-card-content">
                        <div style="position: relative; min-height: 24px; display: flex; align-items: center;">
                            <div class="font-name" style="font-family: '${font.name}', ${getFallbackFont(font.category)}; line-height: normal; vertical-align: baseline;">${font.name}</div>
                            ${capsBadge}
                        </div>
                        <div class="favorite-heart" data-font-name="${font.name}">‚ô•</div>
                        <div class="font-category">${font.category}</div>
                        <div style="position: relative;">
                            <div class="font-preview" id="${previewId}"
                                 style="font-family: '${font.name}', ${getFallbackFont(font.category)};"
                                 data-font-name="${font.name}"
                                 data-fallback-font="${getFallbackFont(font.category)}">
                                 ${displayText}
                            </div>
                        </div>
                        <button class="card-size-increase-btn" title="Increase card text size" onclick="increaseCardTextSize('${previewId}')">+</button>
                    </div>
                    <div class="font-actions">
                        <button class="btn btn-primary" onclick="copyCSS('${font.name}', '${font.category}', event)">Copy CSS</button>
                        <button class="btn btn-secondary" onclick="viewOnGoogle('${font.name}')">View on Google</button>
                    </div>
                    <div class="font-number">${index}</div>
                </div>
            `;
        }

        function checkIfAllCaps(fontName) {
            // Complete list of 29 verified all-caps fonts (removed Swash Caps fonts)
            const trulyAllCaps = [
                'Aboreto', 'Alegreya SC', 'Alegreya Sans SC', 'Almendra SC',
                'Amatic SC', 'Bowlby One SC', 'Bruno Ace SC',
                'Carrois Gothic SC', 'Cormorant SC', 'Diplomata SC',
                'Encode Sans SC', 'Graduate', 'Holtwood One SC',
                'IM Fell DW Pica SC', 'IM Fell Double Pica SC', 'IM Fell English SC',
                'IM Fell French Canon SC', 'IM Fell Great Primer SC', 'Marcellus SC',
                'Mate SC', 'Monoton', 'Overlock SC', 'Patrick Hand SC', 'Playfair Display SC',
                'Six Caps', 'Spectral SC', 'Shojumaru', 'Vollkorn SC', 'Ysabeau SC'
            ];

            return trulyAllCaps.includes(fontName);
        }

        function getFallbackFont(category) {
            switch (category) {
                case 'sans-serif': return 'sans-serif';
                case 'serif': return 'serif';
                case 'cursive': return 'cursive';
                case 'monospace': return 'monospace';
                default: return 'sans-serif';
            }
        }

        function loadFontsForPreview(fonts) {
            // Load actual Google Fonts for true previews
            const head = document.head;

            // Remove any previously loaded font links
            const existingLinks = head.querySelectorAll('link[href*="fonts.googleapis.com"]');
            existingLinks.forEach(link => head.removeChild(link));

            // Load ALL visible fonts (no limit)
            const fontsToLoad = fonts;

            // Log for debugging
            console.log("Polices charg√©es :", fontsToLoad.map(f => f.name));
            console.log("Nombre total :", fontsToLoad.length);

            // Load each font with multiple weights for better variant support
            fontsToLoad.forEach(font => {
                const fontName = font.name.replace(/ /g, '+');
                const fontLink = document.createElement('link');
                // Load regular (400) and bold (700) weights for better variant support
                fontLink.href = `https://fonts.googleapis.com/css2?family=${fontName}:wght@400;700&display=swap`;
                fontLink.rel = 'stylesheet';
                head.appendChild(fontLink);
            });

            // Force normal display for all loaded fonts
            fontsToLoad.forEach(font => {
                const previewId = `preview-${font.name.toLowerCase().replace(/\s+/g, '-')}`;
                const previewElement = document.getElementById(previewId);
                if (previewElement) {
                    previewElement.classList.remove('fallback');
                }
            });
        }

        function checkFontLoading(fontName) {
            const previewId = `preview-${fontName.toLowerCase().replace(/\s+/g, '-')}`;
            const previewElement = document.getElementById(previewId);

            if (!previewElement) return;

            // Create a test element with the expected font
            const testElement = document.createElement('span');
            testElement.style.fontFamily = `'${fontName}', ${previewElement.dataset.fallbackFont}`;
            testElement.style.fontSize = '40px';
            testElement.style.position = 'absolute';
            testElement.style.visibility = 'hidden';
            testElement.textContent = 'ABCabc123';
            document.body.appendChild(testElement);

            // Create a reference element with the fallback font
            const fallbackElement = document.createElement('span');
            fallbackElement.style.fontFamily = previewElement.dataset.fallbackFont;
            fallbackElement.style.fontSize = '40px';
            fallbackElement.style.position = 'absolute';
            fallbackElement.style.visibility = 'hidden';
            fallbackElement.textContent = 'ABCabc123';
            document.body.appendChild(fallbackElement);

            // Measure the width of both elements
            const testWidth = testElement.getBoundingClientRect().width;
            const fallbackWidth = fallbackElement.getBoundingClientRect().width;

            // Clean up
            document.body.removeChild(testElement);
            document.body.removeChild(fallbackElement);

            // If widths are significantly different, the font is loaded
            const isFontLoaded = Math.abs(testWidth - fallbackWidth) > 5; // Threshold of 5px difference

            if (isFontLoaded) {
                previewElement.classList.remove('fallback');
            } else {
                previewElement.classList.add('fallback');
            }
        }

        function updateAllPreviews() {
            const fontCards = document.querySelectorAll('.font-card');
            fontCards.forEach(card => {
                const previewElement = card.querySelector('.font-preview');
                if (previewElement) {
                    const displayText = currentCategory === 'all-caps' ? previewText.toUpperCase() : previewText;
                    previewElement.textContent = displayText;
                }
            });
        }

        // Robust clipboard copy function with fallback for unsupported environments
        function tryCopyToClipboard(text, fontName, isFallback = false) {
            // Check if clipboard API is available
            if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                navigator.clipboard.writeText(text).then(() => {
                    if (isFallback) {
                        alert(`‚ö†Ô∏è Copied fallback CSS for ${fontName}. Could not extract @font-face rules.`);
                    } else {
                        alert(`‚úÖ CSS for ${fontName} copied to clipboard! Check console for debug details.`);
                    }
                }).catch(err => {
                    console.error('Clipboard API failed, trying fallback:', err);
                    // Fallback to textarea method
                    copyToClipboardFallback(text, fontName, isFallback);
                });
            } else {
                // Clipboard API not available, use fallback
                copyToClipboardFallback(text, fontName, isFallback);
            }
        }
        
        // Fallback clipboard copy method using textarea
        function copyToClipboardFallback(text, fontName, isFallback = false) {
            try {
                // Create a temporary textarea element
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';  // Avoid scrolling to bottom
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                
                // Try to execute copy command
                const success = document.execCommand('copy');
                document.body.removeChild(textarea);
                
                if (success) {
                    if (isFallback) {
                        alert(`‚úÖ Copied fallback CSS for ${fontName} to clipboard (using fallback method).`);
                    } else {
                        alert(`‚úÖ CSS for ${fontName} copied to clipboard (using fallback method)!`);
                    }
                } else {
                    // If copy command fails, show the CSS in a modal
                    showCSSInModal(text, fontName, isFallback);
                }
            } catch (err) {
                console.error('Fallback copy method failed:', err);
                // Show CSS in modal as last resort
                showCSSInModal(text, fontName, isFallback);
            }
        }
        
        // Show CSS in a modal dialog for manual copying
        function showCSSInModal(css, fontName, isFallback = false) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            modal.style.zIndex = '10000';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.padding = '20px';
            modal.style.boxSizing = 'border-box';
            
            // Create modal content
            const content = document.createElement('div');
            content.style.backgroundColor = 'white';
            content.style.padding = '20px';
            content.style.borderRadius = '8px';
            content.style.maxWidth = '800px';
            content.style.width = '100%';
            content.style.maxHeight = '80vh';
            content.style.overflow = 'auto';
            content.style.position = 'relative';
            
            // Create close button
            const closeButton = document.createElement('button');
            closeButton.textContent = '√ó';
            closeButton.style.position = 'absolute';
            closeButton.style.top = '10px';
            closeButton.style.right = '10px';
            closeButton.style.background = 'none';
            closeButton.style.border = 'none';
            closeButton.style.fontSize = '24px';
            closeButton.style.cursor = 'pointer';
            closeButton.style.color = '#666';
            closeButton.onclick = function() {
                document.body.removeChild(modal);
            };
            
            // Create title
            const title = document.createElement('h3');
            title.textContent = `CSS for ${fontName}`;
            title.style.marginTop = '0';
            title.style.color = '#4285F4';
            
            // Create subtitle
            const subtitle = document.createElement('p');
            subtitle.textContent = isFallback ? 
                'Could not copy automatically. Please manually copy the CSS below:' : 
                'Could not copy automatically. Please manually copy the CSS below:';
            subtitle.style.color = '#666';
            subtitle.style.marginBottom = '15px';
            
            // Create CSS textarea
            const cssTextarea = document.createElement('textarea');
            cssTextarea.value = css;
            cssTextarea.style.width = '100%';
            cssTextarea.style.height = '300px';
            cssTextarea.style.fontFamily = 'monospace';
            cssTextarea.style.fontSize = '14px';
            cssTextarea.style.padding = '10px';
            cssTextarea.style.border = '1px solid #ddd';
            cssTextarea.style.borderRadius = '4px';
            cssTextarea.style.resize = 'vertical';
            cssTextarea.style.marginBottom = '15px';
            
            // Create copy instructions
            const instructions = document.createElement('p');
            instructions.innerHTML = '<strong>To use this CSS:</strong><br>' +
                '1. Select all text above (Ctrl+A or Cmd+A)<br>' +
                '2. Copy it (Ctrl+C or Cmd+C)<br>' +
                '3. Paste it into your stylesheet<br>' +
                '4. Use the provided class names in your HTML';
            instructions.style.color = '#666';
            instructions.style.fontSize = '14px';
            
            // Assemble modal
            content.appendChild(closeButton);
            content.appendChild(title);
            content.appendChild(subtitle);
            content.appendChild(cssTextarea);
            content.appendChild(instructions);
            modal.appendChild(content);
            
            // Add modal to body
            document.body.appendChild(modal);
            
            // Auto-select CSS text
            cssTextarea.select();
        }
        
        async function copyCSS(fontName, category, event) {
            // Prevent event bubbling if event is passed
            if (event) {
                event.stopPropagation();
            }
            
            const fontNameUrl = fontName.replace(/ /g, '+');
            const fontNameKebab = fontName.toLowerCase().replace(/ /g, '-');

            try {
                // Fetch the actual CSS from Google Fonts API with comprehensive variable font syntax
                // First try the optimal variable font format, then fall back to individual weights if needed
                let response;
                try {
                    // Try variable font format first (most efficient)
                    response = await fetch(`https://fonts.googleapis.com/css2?family=${fontNameUrl}:ital,wght@0,100..900;1,100..900&display=swap`);
                } catch (error) {
                    console.log('Variable font request failed, trying comprehensive format');
                    // Fallback to comprehensive individual weights format
                    response = await fetch(`https://fonts.googleapis.com/css2?family=${fontNameUrl}:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`);
                }
                
                if (!response.ok) {
                    throw new Error('Failed to fetch font CSS');
                }

                const fontCSS = await response.text();
                
                // Simple and reliable extraction: get all @font-face rules from the CSS
                console.log('Starting CSS extraction for:', fontName);
                console.log('Full CSS length:', fontCSS.length);
                
                const ruleMatches = fontCSS.match(/@font-face[^}]+}/g);
                
                console.log('Total @font-face rules found:', ruleMatches ? ruleMatches.length : 0);
                
                let fontFaceRulesText = '';
                
                if (ruleMatches && ruleMatches.length > 0) {
                    // Filter to only include latin subset rules
                    const latinRules = ruleMatches.filter(rule => {
                        // Check if this rule is likely part of latin subset
                        // (Google Fonts puts latin rules after /* latin */ comment)
                        const isLatin = rule.includes('unicode-range') && 
                                      (rule.includes('U+0000-00FF') || rule.includes('U+0041-007A'));
                        if (isLatin) {
                            console.log('Found latin rule:', rule.substring(0, 100) + '...');
                        }
                        return isLatin;
                    });
                    
                    console.log('Latin rules found:', latinRules.length);
                    
                    if (latinRules.length > 0) {
                        fontFaceRulesText = latinRules.join('\n\n');
                    } else {
                        // Fallback: use all rules if we can't filter properly
                        console.log('No latin rules found, using all rules');
                        fontFaceRulesText = ruleMatches.join('\n\n');
                    }
                } else {
                    // If no @font-face rules found, try the original method
                    console.log('No @font-face rules found with regex, trying alternative method');
                    const latinSection = fontCSS.split('/* latin */')[1];
                    if (latinSection) {
                        const nextSubset = latinSection.split('/* ')[0];
                        const ruleMatchesFallback = nextSubset.match(/@font-face[^}]+}/g);
                        fontFaceRulesText = ruleMatchesFallback ? ruleMatchesFallback.join('\n\n') : '';
                        console.log('Fallback rules found:', ruleMatchesFallback ? ruleMatchesFallback.length : 0);
                    } else {
                        throw new Error('No @font-face rules found in font CSS');
                    }
                }

                if (fontFaceRulesText) {
                    // Check if we can optimize for variable fonts
                    const hasVariableFont = fontFaceRulesText.includes('font-weight: 100 900');
                    
                    let optimizedRules = fontFaceRulesText;
                    
                    // For variable fonts, we can often consolidate multiple weight rules
                    if (hasVariableFont) {
                        // Keep only the variable font rules and remove individual weight rules
                        const lines = fontFaceRulesText.split('\n');
                        const filteredLines = [];
                        let inVariableRule = false;
                        let currentFontStyle = '';
                        
                        for (const line of lines) {
                            if (line.includes('@font-face')) {
                                // Start of a new rule - check if it's a variable font
                                if (line.includes('font-weight: 100 900')) {
                                    inVariableRule = true;
                                    filteredLines.push(line);
                                } else {
                                    inVariableRule = false;
                                }
                            } else if (inVariableRule) {
                                filteredLines.push(line);
                                if (line.includes('}')) {
                                    inVariableRule = false;
                                }
                            }
                        }
                        
                        // If we found variable fonts, use them
                        if (filteredLines.length > 0) {
                            optimizedRules = filteredLines.join('\n');
                        }
                    }
                    
                    // Create comprehensive CSS with the actual @font-face rules
                    const css = `
/* ${fontName} - ${category} */
/* üéØ EXCLUSIVE: Latin subset @font-face rules from Google Fonts */
/* Note: Some fonts use individual weight files, others use variable fonts */
/* Includes ALL available weights and style variants from Google Fonts */
/* No Cyrillic, Greek, Latin-Ext, or other subsets included */
${optimizedRules}

/* üìã CSS Usage Examples */
.${fontNameKebab}-regular {
    font-family: '${fontName}', ${category};
    font-weight: 400;
}

.${fontNameKebab}-bold {
    font-family: '${fontName}', ${category};
    font-weight: 700;
}

/* üí° CSS Variables (optional) */
:root {
    --font-${fontNameKebab}: "${fontName}", ${category};
}

.${fontNameKebab} {
    font-family: var(--font-${fontNameKebab});
}

/* üé® Usage Examples:
   <div class="${fontNameKebab}-regular">Regular text</div>
   <div class="${fontNameKebab}-bold">Bold text</div>
   <div class="${fontNameKebab}" style="font-weight: 400;">Using CSS variable</div>
*/

/* ‚ö†Ô∏è  Note: These are the actual @font-face rules from Google Fonts.
   The URLs point to the real font files hosted on Google's CDN.
   For self-hosting, you would need to download these font files.
*/
                    `;

                    // Try to copy to clipboard with fallback for unsupported environments
                    tryCopyToClipboard(css, fontName);
                } else {
                    // Fallback to the original method if extraction fails
                    const fallbackCSS = `
/* ${fontName} - ${category} */
/* Fallback: Use Google Fonts CDN */
<link href="https://fonts.googleapis.com/css2?family=${fontNameUrl}:wght@400;700&display=swap" rel="stylesheet">

.${fontNameKebab}-regular {
    font-family: '${fontName}', ${category};
    font-weight: 400;
}

.${fontNameKebab}-bold {
    font-family: '${fontName}', ${category};
    font-weight: 700;
}
                    `;

                    // Try to copy fallback CSS to clipboard
                    tryCopyToClipboard(fallbackCSS, fontName, true);
                }
            } catch (error) {
                console.error('Error copying CSS:', error);
                
                // Fallback to simple CSS if API call fails
                const simpleCSS = `
/* ${fontName} - ${category} */
<link href="https://fonts.googleapis.com/css2?family=${fontNameUrl}:wght@400;700&display=swap" rel="stylesheet">

.${fontNameKebab} {
    font-family: '${fontName}', ${category};
}
                `;

                // Try to copy simple CSS to clipboard
                tryCopyToClipboard(simpleCSS, fontName, true);
            }
        }

        function viewOnGoogle(fontName) {
            window.open(`https://fonts.google.com/specimen/${fontName.replace(/ /g, '+')}`, '_blank');
        }

        // Load favorites from localStorage
        function loadFavorites() {
            const savedFavorites = localStorage.getItem('favoriteFonts');
            if (savedFavorites) {
                try {
                    const parsed = JSON.parse(savedFavorites);
                    if (Array.isArray(parsed)) {
                        parsed.forEach(fontName => favorites.add(fontName));
                        console.log('Loaded ' + favorites.size + ' favorites');
                        
                        // Update heart icons to reflect loaded favorites
                        updateFavoriteHearts();
                    }
                } catch (e) {
                    console.error('Error loading favorites:', e);
                }
            } else {
                console.log('No favorites found in localStorage');
            }
        }
        
        function updateFavoriteHearts() {
            // Update all heart icons based on current favorites
            const heartIcons = document.querySelectorAll('.favorite-heart');
            heartIcons.forEach(heart => {
                const fontName = heart.dataset.fontName;
                if (favorites.has(fontName)) {
                    heart.classList.add('favorited');
                } else {
                    heart.classList.remove('favorited');
                }
            });
        }
        
        // Save favorites to localStorage
        function saveFavorites() {
            const favoritesArray = Array.from(favorites);
            localStorage.setItem('favoriteFonts', JSON.stringify(favoritesArray));
        }
        
        // Start the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            init();
            loadFavorites();
            loadThemePreference();
        });
        
        // Also call it immediately in case DOM is already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            init();
            loadFavorites();
            loadThemePreference();
        }
        
        // Force show favorites button for testing (remove this later)
        setTimeout(() => {
            const favoritesBtn = document.querySelector('.category-btn[data-category="favorites"]');
            if (favoritesBtn) {
                favoritesBtn.style.display = 'inline-block';
            }
        }, 100);
    </script>
</body></html>
