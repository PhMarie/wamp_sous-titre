<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Fonts Showcase</title>
    
    <!-- Favicon with different colors -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%234285F4'/><text x='50' y='60' font-family='Arial, sans-serif' font-size='50' fill='white' text-anchor='middle' font-weight='bold'>G</text></svg>" type="image/svg+xml">
    
    <!-- External CSS file -->
    <link rel="stylesheet" href="styles.css">
    
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üé® Google Fonts Showcase</h1>
            <p class="subtitle">Browse and preview beautiful Google Fonts</p>
            <div class="font-counter" id="font-counter"><span id="category-name">All Fonts</span>: <span id="category-count">0</span> fonts</div>
        </header>

        <div class="sticky-controls">
            <div class="search-container">
                <input type="text" id="font-search" placeholder="üîç Search fonts by name...">
            </div>

            <div class="font-categories">
                <button class="category-btn active" data-category="all">All Fonts</button>
                <button class="category-btn" data-category="caps">CAPS</button>
                <button class="category-btn" data-category="sans-serif">Sans Serif</button>
                <button class="category-btn" data-category="serif">Serif</button>
                <button class="category-btn" data-category="cursive">Cursive</button>
                <button class="category-btn" data-category="monospace">Monospace</button>
                <button class="category-btn" data-category="favorites">‚ù§Ô∏è Favorites</button>
                <button class="theme-toggle-btn" id="theme-toggle">üåì Dark Theme</button>
            </div>

            <div class="preview-text-input">
                <div style="position: relative;">
                    <input type="text" id="preview-text" placeholder="Enter text to preview..."
                        value="Gloire √† l'√©t√© br√ªlant, √† l'hiver glac√© : voil√† deux saisons bien diff√©rentes ! √ätre 123 √âl√©phants, ou 456 √àve ?">
                    <div class="preview-text-controls">
                        <button class="preview-text-control-btn" id="increase-font-size" title="Increase font size">+</button>
                        <button class="preview-text-control-btn" id="reset-preview-font" title="Reset font">√ó</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="pagination-top-container">
            <!-- Top pagination will be inserted here by JavaScript -->
        </div>
        <div class="fonts-grid" id="fonts-container">
            <div class="loading">Loading fonts...</div>
        </div>
    </div>

    <script>
        // Global variables
        let allFonts = [];
        let currentCategory = 'all';
        let previewText = "Gloire √† l'√©t√© br√ªlant, √† l'hiver glac√© : voil√† deux saisons bien diff√©rentes ! √ätre 123 √âl√©phants, ou 456 √àve ?";
        let currentPage = 1;
        const fontsPerPage = 21; // Number of fonts to display per page (7x3 grid = 21)
        const favorites = new Set(); // Store favorite fonts
        let isDarkTheme = false; // Track dark theme state

        // DOM elements
        const fontsContainer = document.getElementById('fonts-container');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const fontSearch = document.getElementById('font-search');
        const previewTextInput = document.getElementById('preview-text');
        const categoryButtons = document.querySelectorAll('.category-btn');

        // Add beautiful background with 4 large cursive corner letters and pattern
        function addBackgroundLetters() {
            console.log('Adding beautiful background pattern...');
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const body = document.body;
            const patternContainer = document.createElement('div');
            patternContainer.className = 'background-letters';
            
            // Add 4 large cursive characters in corners (mix of letters and numbers)
            const allCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const cornerCharacters = [];
            
            // Generate 4 random characters (ensure at least 2 are numbers)
            for (let i = 0; i < 4; i++) {
                if (i < 2 || Math.random() < 0.5) {
                    // First two are numbers, or 50% chance for others
                    const numbers = '0123456789';
                    cornerCharacters.push(numbers[Math.floor(Math.random() * numbers.length)]);
                } else {
                    // Letter
                    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                    cornerCharacters.push(letters[Math.floor(Math.random() * letters.length)]);
                }
            }
            
            const cornerPositions = [
                {top: 5, left: 3, size: 200, font: 'cursive'},
                {top: 8, right: 5, size: 250, font: 'cursive'},
                {bottom: 15, left: 2, size: 220, font: 'cursive'},
                {bottom: 10, right: 4, size: 180, font: 'cursive'}
            ];
            
            cornerCharacters.forEach((char, index) => {
                const cornerElement = document.createElement('div');
                cornerElement.className = 'background-letter corner-letter';
                cornerElement.textContent = char;
                // Use different elegant fonts for each corner
                const elegantFonts = [
                    'cursive',
                    'fantasy',
                    'cursive',
                    'fantasy'
                ];
                cornerElement.style.fontFamily = elegantFonts[index];
                
                // Add some font variation with CSS properties
                if (index === 0) {
                    cornerElement.style.fontStyle = 'italic';
                } else if (index === 1) {
                    cornerElement.style.fontWeight = '600';
                } else if (index === 2) {
                    cornerElement.style.fontStyle = 'italic';
                    cornerElement.style.fontWeight = '600';
                }
                cornerElement.style.fontSize = cornerPositions[index].size + 'px';
                cornerElement.style.top = cornerPositions[index].top + '%';
                cornerElement.style.left = cornerPositions[index].left + '%';
                cornerElement.style.right = cornerPositions[index].right + '%';
                cornerElement.style.bottom = cornerPositions[index].bottom + '%';
                cornerElement.style.transform = `rotate(${Math.random() * 15 - 7.5}deg)`;
                cornerElement.style.opacity = '0.6';
                cornerElement.style.color = 'rgba(220, 220, 220, 0.6)'; /* Lighter grey */
                
                patternContainer.appendChild(cornerElement);
            });
            
            // Add pattern of smaller letters and numbers
            const patternCount = 30;
            
            for (let i = 0; i < patternCount; i++) {
                const charElement = document.createElement('div');
                charElement.className = 'background-letter pattern-letter';
                
                // Random character
                const randomChar = characters[Math.floor(Math.random() * characters.length)];
                // Make numbers slightly more likely (60% letters, 40% numbers)
                if (Math.random() < 0.4) {
                    const numbers = '0123456789';
                    charElement.textContent = numbers[Math.floor(Math.random() * numbers.length)];
                } else {
                    charElement.textContent = randomChar;
                }
                
                // Random positioning (avoid corners)
                const top = 15 + Math.random() * 70; // 15% to 85% from top
                const left = 10 + Math.random() * 80; // 10% to 90% from left
                const size = 30 + Math.random() * 80; // 30px to 110px
                const rotation = Math.random() * 40 - 20; // -20¬∞ to +20¬∞
                
                charElement.style.top = top + '%';
                charElement.style.left = left + '%';
                charElement.style.fontSize = size + 'px';
                charElement.style.transform = `rotate(${rotation}deg)`;
                charElement.style.opacity = Math.random() * 0.2 + 0.1; // 0.1 to 0.3 opacity
                charElement.style.color = 'rgba(200, 200, 200, 0.6)';
                
                patternContainer.appendChild(charElement);
            }
            
            body.insertBefore(patternContainer, body.firstChild);
            console.log('Beautiful background pattern added!');
        }

        // Call the function when page loads
        document.addEventListener('DOMContentLoaded', addBackgroundLetters);
        
        // Also call it immediately in case DOM is already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            addBackgroundLetters();
        }

        // Initialize the app
        async function init() {
            try {
                // Load font data
                const response = await fetch('google-fonts.json');
                if (!response.ok) {
                    throw new Error('Failed to load font data');
                }

                allFonts = await response.json();

                // Convert font data to array format
                allFonts = Object.entries(allFonts).map(([name, data]) => ({
                    name,
                    category: data.category === 'handwriting' ? 'cursive' : data.category,
                    subsets: data.subsets || [],
                    variants: data.variants || {}
                }));

                // Filter fonts with Latin subset
                allFonts = allFonts.filter(font => font.subsets.includes('latin'));

                // Display fonts
                displayFonts();

                // Set up event listeners
                setupEventListeners();

            } catch (error) {
                console.error('Error loading fonts:', error);
                fontsContainer.innerHTML = `<div class="no-results">Error loading fonts. Please try again later.</div>`;
            }
        }

        function setupEventListeners() {
            // Search functionality
            fontSearch.addEventListener('input', () => {
                displayFonts();
            });

            // Preview text functionality
            previewTextInput.addEventListener('input', () => {
                previewText = previewTextInput.value;
                updateAllPreviews();
            });

            // Theme toggle button
            themeToggleBtn.addEventListener('click', () => {
                toggleTheme();
            });

            // Font card clicks - change preview text font
            document.addEventListener('click', (e) => {
                const fontCard = e.target.closest('.font-card');
                if (fontCard) {
                    const fontName = fontCard.dataset.fontName;
                    const fontCategory = fontCard.dataset.fontCategory;
                    changePreviewFont(fontName, fontCategory);
                }
            });

            // Font size increase button
            const increaseFontSizeBtn = document.getElementById('increase-font-size');
            if (increaseFontSizeBtn) {
                increaseFontSizeBtn.addEventListener('click', () => {
                    increasePreviewFontSize();
                });
            }

            // Reset preview font button
            const resetPreviewFontBtn = document.getElementById('reset-preview-font');
            if (resetPreviewFontBtn) {
                resetPreviewFontBtn.addEventListener('click', () => {
                    resetPreviewFont();
                });
            }

            // Category buttons
            categoryButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons
                    categoryButtons.forEach(btn => btn.classList.remove('active'));

                    // Add active class to clicked button
                    button.classList.add('active');

                    // Update current category
                    currentCategory = button.dataset.category;

                    // Display fonts for selected category
                    displayFonts();
                });
            });
            
            // Favorite heart clicks
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('favorite-heart')) {
                    const fontName = e.target.dataset.fontName;
                    
                    // Toggle favorite status
                    if (favorites.has(fontName)) {
                        favorites.delete(fontName);
                        e.target.classList.remove('favorited');
                    } else {
                        favorites.add(fontName);
                        e.target.classList.add('favorited');
                    }
                    
                    // Save to localStorage
                    saveFavorites();
                    
                    // Show favorites button immediately
                    const favoritesBtn = document.querySelector('.category-btn[data-category="favorites"]');
                    if (favoritesBtn) {
                        if (favorites.size > 0) {
                            favoritesBtn.style.display = 'inline-block';
                        } else {
                            favoritesBtn.style.display = 'none';
                        }
                    }
                    
                    // Update favorites count if favorites category is active
                    if (currentCategory === 'favorites') {
                        displayFonts();
                    }
                }
            });
        }

        function toggleTheme() {
            isDarkTheme = !isDarkTheme;
            document.body.classList.toggle('dark-theme');
            
            // Update button text based on current theme
            themeToggleBtn.textContent = isDarkTheme ? '‚òÄÔ∏è Light Theme' : 'üåì Dark Theme';
            
            // Save theme preference to localStorage
            localStorage.setItem('themePreference', isDarkTheme ? 'dark' : 'light');
        }

        function loadThemePreference() {
            const savedTheme = localStorage.getItem('themePreference');
            if (savedTheme === 'dark') {
                isDarkTheme = true;
                document.body.classList.add('dark-theme');
                themeToggleBtn.textContent = '‚òÄÔ∏è Light Theme';
            }
        }

        function changePreviewFont(fontName, fontCategory) {
            const previewTextElement = document.getElementById('preview-text');
            if (previewTextElement) {
                // Store the current font selection
                previewTextElement.dataset.currentFont = fontName;
                previewTextElement.dataset.currentFontCategory = fontCategory;
                
                // Update the preview text styling to show it's using the selected font
                previewTextElement.style.fontFamily = `'${fontName}', ${getFallbackFont(fontCategory)}`;
                previewTextElement.style.fontSize = currentFontSize + 'px';
                previewTextElement.style.fontWeight = 'normal';
                
                // Reset size tracking to default
                currentSizeIndex = 0;
                
                // Add a visual indicator
                previewTextElement.classList.add('using-card-font');
                
                // Show a temporary notification
                showFontSelectionNotification(fontName);
            }
        }

        function showFontSelectionNotification(fontName) {
            // Remove any existing notification
            const existingNotification = document.querySelector('.font-selection-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification
            const notification = document.createElement('div');
            notification.className = 'font-selection-notification';
            notification.textContent = `Preview text now uses: ${fontName}`;
            
            // Style the notification
            notification.style.position = 'fixed';
            notification.style.bottom = '20px';
            notification.style.right = '20px';
            notification.style.padding = '12px 20px';
            notification.style.backgroundColor = '#4285F4';
            notification.style.color = 'white';
            notification.style.borderRadius = '25px';
            notification.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
            notification.style.zIndex = '1000';
            notification.style.fontSize = '14px';
            notification.style.fontWeight = '500';
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(20px)';
            notification.style.transition = 'opacity 0.3s, transform 0.3s';
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function resetPreviewFont() {
            const previewTextElement = document.getElementById('preview-text');
            if (previewTextElement) {
                // Remove the custom font styling
                previewTextElement.style.fontFamily = '';
                previewTextElement.style.fontSize = '';
                previewTextElement.style.fontWeight = '';
                
                // Remove the visual indicator class
                previewTextElement.classList.remove('using-card-font');
                
                // Clear the stored font data
                delete previewTextElement.dataset.currentFont;
                delete previewTextElement.dataset.currentFontCategory;
                
                // Reset font size tracking
                currentFontSize = 18;
                currentSizeIndex = 0;
                
                // Show reset notification
                showFontResetNotification();
            }
        }

        function showFontResetNotification() {
            // Remove any existing notification
            const existingNotification = document.querySelector('.font-selection-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification
            const notification = document.createElement('div');
            notification.className = 'font-selection-notification';
            notification.textContent = 'Preview text reset to default font';
            
            // Style the notification (already styled via CSS class)
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // Font size management
        let currentFontSize = 18; // Default size when using card font
        const fontSizeSteps = [18, 22, 26, 30]; // Available font sizes
        let currentSizeIndex = 0; // Current index in fontSizeSteps

        function increasePreviewFontSize() {
            const previewTextElement = document.getElementById('preview-text');
            if (previewTextElement && previewTextElement.classList.contains('using-card-font')) {
                // Cycle through font sizes
                currentSizeIndex = (currentSizeIndex + 1) % fontSizeSteps.length;
                currentFontSize = fontSizeSteps[currentSizeIndex];
                
                previewTextElement.style.fontSize = currentFontSize + 'px';
                
                // Update button active state
                updateSizeButtonStates();
                
                // Show notification
                showFontSizeNotification(currentFontSize);
            }
        }

        function updateSizeButtonStates() {
            const increaseBtn = document.getElementById('increase-font-size');
            if (increaseBtn) {
                // Add active class to show current size
                increaseBtn.classList.add('active');
                
                // Remove active class after a short delay
                setTimeout(() => {
                    increaseBtn.classList.remove('active');
                }, 500);
            }
        }

        function showFontSizeNotification(size) {
            // Remove any existing notification
            const existingNotification = document.querySelector('.font-selection-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification
            const notification = document.createElement('div');
            notification.className = 'font-selection-notification';
            notification.textContent = `Font size: ${size}px`;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove after 2 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }

        function displayFonts() {
            // Show/hide favorites category based on favorites count
            const favoritesBtn = document.querySelector('.category-btn[data-category="favorites"]');
            if (favoritesBtn) {
                if (favorites.size === 0) {
                    favoritesBtn.style.display = 'none';
                } else {
                    favoritesBtn.style.display = 'inline-block'; // Ensure it's visible
                }
            }
            const searchTerm = fontSearch.value.toLowerCase();

            // Show loading state
            fontsContainer.innerHTML = `<div class="loading">Loading fonts...</div>`;

            // Filter fonts
            let filteredFonts = allFonts.filter(font => {
                // Filter by category
                if (currentCategory === 'favorites') {
                    // Filter for favorite fonts
                    if (!favorites.has(font.name)) {
                        return false;
                    }
                } else if (currentCategory === 'caps') {
                    // Filter for truly all-caps fonts and SC/Caps fonts
                    // Complete list of 29 verified all-caps fonts (removed Swash Caps fonts)
                    const trulyAllCaps = [
                        'Aboreto', 'Alegreya SC', 'Alegreya Sans SC', 'Almendra SC',
                        'Amatic SC', 'Bowlby One SC', 'Bruno Ace SC',
                        'Carrois Gothic SC', 'Cormorant SC', 'Diplomata SC',
                        'Encode Sans SC', 'Graduate', 'Holtwood One SC',
                        'IM Fell DW Pica SC', 'IM Fell Double Pica SC', 'IM Fell English SC',
                        'IM Fell French Canon SC', 'IM Fell Great Primer SC', 'Marcellus SC',
                        'Mate SC', 'Monoton', 'Overlock SC', 'Patrick Hand SC', 'Playfair Display SC',
                        'Six Caps', 'Spectral SC', 'Shojumaru', 'Vollkorn SC', 'Ysabeau SC'
                    ];

                    // Also include SC (Small Caps) and Caps fonts
                    const hasSCorCaps = /\b(SC|Caps)\b/i.test(font.name);

                    // Exceptions: SC fonts and Swash Caps fonts that are NOT truly all-caps
                    const scExceptions = [
                        'Noto Sans SC', 'Noto Serif SC',
                        'Macondo Swash Caps', 'Oleo Script Swash Caps',
                        'Bilbo Swash Caps', 'Delius Swash Caps', 'Elsie Swash Caps'
                    ];

                    const isSCFont = hasSCorCaps && !scExceptions.includes(font.name);

                    return trulyAllCaps.includes(font.name) || isSCFont;
                } else if (currentCategory !== 'all' && font.category !== currentCategory) {
                    return false;
                }

                // Filter by search term
                if (searchTerm && !font.name.toLowerCase().includes(searchTerm)) {
                    return false;
                }

                return true;
            });

            // Update font counter with proper format: "Category: X fonts"
            const counterElement = document.getElementById('font-counter');
            const categoryNameElement = document.getElementById('category-name');
            const categoryCountElement = document.getElementById('category-count');
            
            const categoryName = currentCategory === 'caps' ? 'CAPS Fonts' :
                               currentCategory === 'all' ? 'All Fonts' : 
                               currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1) + ' Fonts';
            
            if (categoryNameElement && categoryCountElement) {
                categoryNameElement.textContent = currentCategory === 'caps' ? 'CAPS Fonts' :
                                               currentCategory === 'all' ? 'All Fonts' : 
                                               currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1);
                categoryCountElement.textContent = filteredFonts.length;
            }
            
            // Update the counter element to show "Category: X fonts"
            if (currentCategory === 'favorites') {
                console.log('Favorites set:', Array.from(favorites));
                counterElement.innerHTML = `‚ù§Ô∏è Favorites: <strong>${filteredFonts.length}</strong> fonts`;
            } else {
                counterElement.innerHTML = `${categoryName}: <strong>${filteredFonts.length}</strong> fonts`;
            }

            // Display fonts or no results message
            if (filteredFonts.length === 0) {
                fontsContainer.innerHTML = `<div class="no-results" style="text-align: center;">No fonts found. Try a different search or category.</div>`;
                return;
            }

            // Pagination logic
            const totalPages = Math.ceil(filteredFonts.length / fontsPerPage);

            const startIndex = (currentPage - 1) * fontsPerPage;
            const endIndex = Math.min(startIndex + fontsPerPage, filteredFonts.length);
            const paginatedFonts = filteredFonts.slice(startIndex, endIndex);

            // Generate font cards with numbering
            fontsContainer.innerHTML = paginatedFonts.map((font, index) => createFontCard(font, startIndex + index + 1)).join('');

            // Add pagination controls at both top and bottom
            addPaginationControls(filteredFonts.length, totalPages, 'top');
            addPaginationControls(filteredFonts.length, totalPages, 'bottom');

            // Small delay to allow DOM to update before loading fonts
            // Update favorite hearts after displaying fonts
            updateFavoriteHearts();
            
            setTimeout(() => {
                loadFontsForPreview(paginatedFonts);
            }, 100);
        }

        function addPaginationControls(totalFonts, totalPages, position = 'bottom') {
            // Remove existing pagination controls for this position
            const existingPagination = document.querySelectorAll('.pagination');
            existingPagination.forEach(pagination => {
                if ((position === 'top' && pagination.classList.contains('pagination-top')) ||
                    (position === 'bottom' && !pagination.classList.contains('pagination-top'))) {
                    pagination.remove();
                }
            });

            // Create pagination container
            const paginationContainer = document.createElement('div');
            paginationContainer.className = 'pagination';
            if (position === 'top') {
                paginationContainer.className = 'pagination pagination-top';
            }

            // Previous button
            const prevButton = document.createElement('button');
            prevButton.textContent = '‚Üê';
            prevButton.disabled = currentPage === 1 || totalPages <= 1;
            prevButton.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    displayFonts();
                }
            });
            paginationContainer.appendChild(prevButton);

            // Page info
            const pageInfo = document.createElement('span');
            pageInfo.className = 'pagination-info';
            const startItem = (currentPage - 1) * fontsPerPage + 1;
            const endItem = Math.min(currentPage * fontsPerPage, totalFonts);
            pageInfo.innerHTML = `Page <strong>${currentPage}</strong> of ${totalPages} (${startItem}-${endItem} of <strong>${totalFonts}</strong>)`;
            paginationContainer.appendChild(pageInfo);

            // Next button
            const nextButton = document.createElement('button');
            nextButton.textContent = '‚Üí';
            nextButton.disabled = currentPage === totalPages || totalPages <= 1;
            nextButton.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    displayFonts();
                }
            });
            paginationContainer.appendChild(nextButton);

            // Add pagination to the page
            if (position === 'top') {
                const topContainer = document.getElementById('pagination-top-container');
                if (topContainer) {
                    topContainer.appendChild(paginationContainer);
                }
            } else {
                fontsContainer.parentNode.insertBefore(paginationContainer, fontsContainer.nextSibling);
            }
        }

        function createFontCard(font, index) {
            // Create a unique class name for this font
            const fontClass = `font-${font.name.toLowerCase().replace(/\s+/g, '-')}`;
            const previewId = `preview-${font.name.toLowerCase().replace(/\s+/g, '-')}`;

            // Determine preview text based on category
            const displayText = currentCategory === 'all-caps' ? previewText.toUpperCase() : previewText;

            // Check if font is truly all-caps (for CAPS category)
            const isAllCaps = checkIfAllCaps(font.name);
            const capsBadge = isAllCaps ? '<div class="caps-badge">‚úÖ CAPS</div>' : '';

            return `
                <div class="font-card ${fontClass}" data-font-name="${font.name}" data-font-category="${font.category}">
                    <div class="font-number">${index}</div>
                    <div class="font-card-content">
                        <div style="position: relative; min-height: 24px; display: flex; align-items: center;">
                            <div class="font-name" style="font-family: '${font.name}', ${getFallbackFont(font.category)}; line-height: normal; vertical-align: baseline;">${font.name}</div>
                            ${capsBadge}
                        </div>
                        <div class="favorite-heart" data-font-name="${font.name}">‚ô•</div>
                        <div class="font-category">${font.category}</div>
                        <div class="font-preview" id="${previewId}"
                             style="font-family: '${font.name}', ${getFallbackFont(font.category)}"
                             data-font-name="${font.name}"
                             data-fallback-font="${getFallbackFont(font.category)}">
                             ${displayText}
                        </div>
                    </div>
                    <div class="font-actions">
                        <button class="btn btn-primary" onclick="copyCSS('${font.name}', '${font.category}')">Copy CSS</button>
                        <button class="btn btn-secondary" onclick="viewOnGoogle('${font.name}')">View on Google</button>
                    </div>
                </div>
            `;
        }

        function checkIfAllCaps(fontName) {
            // Complete list of 29 verified all-caps fonts (removed Swash Caps fonts)
            const trulyAllCaps = [
                'Aboreto', 'Alegreya SC', 'Alegreya Sans SC', 'Almendra SC',
                'Amatic SC', 'Bowlby One SC', 'Bruno Ace SC',
                'Carrois Gothic SC', 'Cormorant SC', 'Diplomata SC',
                'Encode Sans SC', 'Graduate', 'Holtwood One SC',
                'IM Fell DW Pica SC', 'IM Fell Double Pica SC', 'IM Fell English SC',
                'IM Fell French Canon SC', 'IM Fell Great Primer SC', 'Marcellus SC',
                'Mate SC', 'Monoton', 'Overlock SC', 'Patrick Hand SC', 'Playfair Display SC',
                'Six Caps', 'Spectral SC', 'Shojumaru', 'Vollkorn SC', 'Ysabeau SC'
            ];

            return trulyAllCaps.includes(fontName);
        }

        function getFallbackFont(category) {
            switch (category) {
                case 'sans-serif': return 'sans-serif';
                case 'serif': return 'serif';
                case 'cursive': return 'cursive';
                case 'monospace': return 'monospace';
                default: return 'sans-serif';
            }
        }

        function loadFontsForPreview(fonts) {
            // Load actual Google Fonts for true previews
            const head = document.head;

            // Remove any previously loaded font links
            const existingLinks = head.querySelectorAll('link[href*="fonts.googleapis.com"]');
            existingLinks.forEach(link => head.removeChild(link));

            // Load ALL visible fonts (no limit)
            const fontsToLoad = fonts;

            // Log for debugging
            console.log("Polices charg√©es :", fontsToLoad.map(f => f.name));
            console.log("Nombre total :", fontsToLoad.length);

            // Load each font with multiple weights for better variant support
            fontsToLoad.forEach(font => {
                const fontName = font.name.replace(/ /g, '+');
                const fontLink = document.createElement('link');
                // Load regular (400) and bold (700) weights for better variant support
                fontLink.href = `https://fonts.googleapis.com/css2?family=${fontName}:wght@400;700&display=swap`;
                fontLink.rel = 'stylesheet';
                head.appendChild(fontLink);
            });

            // Force normal display for all loaded fonts
            fontsToLoad.forEach(font => {
                const previewId = `preview-${font.name.toLowerCase().replace(/\s+/g, '-')}`;
                const previewElement = document.getElementById(previewId);
                if (previewElement) {
                    previewElement.classList.remove('fallback');
                }
            });
        }

        function checkFontLoading(fontName) {
            const previewId = `preview-${fontName.toLowerCase().replace(/\s+/g, '-')}`;
            const previewElement = document.getElementById(previewId);

            if (!previewElement) return;

            // Create a test element with the expected font
            const testElement = document.createElement('span');
            testElement.style.fontFamily = `'${fontName}', ${previewElement.dataset.fallbackFont}`;
            testElement.style.fontSize = '40px';
            testElement.style.position = 'absolute';
            testElement.style.visibility = 'hidden';
            testElement.textContent = 'ABCabc123';
            document.body.appendChild(testElement);

            // Create a reference element with the fallback font
            const fallbackElement = document.createElement('span');
            fallbackElement.style.fontFamily = previewElement.dataset.fallbackFont;
            fallbackElement.style.fontSize = '40px';
            fallbackElement.style.position = 'absolute';
            fallbackElement.style.visibility = 'hidden';
            fallbackElement.textContent = 'ABCabc123';
            document.body.appendChild(fallbackElement);

            // Measure the width of both elements
            const testWidth = testElement.getBoundingClientRect().width;
            const fallbackWidth = fallbackElement.getBoundingClientRect().width;

            // Clean up
            document.body.removeChild(testElement);
            document.body.removeChild(fallbackElement);

            // If widths are significantly different, the font is loaded
            const isFontLoaded = Math.abs(testWidth - fallbackWidth) > 5; // Threshold of 5px difference

            if (isFontLoaded) {
                previewElement.classList.remove('fallback');
            } else {
                previewElement.classList.add('fallback');
            }
        }

        function updateAllPreviews() {
            const fontCards = document.querySelectorAll('.font-card');
            fontCards.forEach(card => {
                const previewElement = card.querySelector('.font-preview');
                if (previewElement) {
                    const displayText = currentCategory === 'all-caps' ? previewText.toUpperCase() : previewText;
                    previewElement.textContent = displayText;
                }
            });
        }

        async function copyCSS(fontName, category) {
            const fontNameUrl = fontName.replace(/ /g, '+');
            const fontNameKebab = fontName.toLowerCase().replace(/ /g, '-');

            try {
                // Fetch the actual CSS from Google Fonts API with comprehensive variable font syntax
                // First try the optimal variable font format, then fall back to individual weights if needed
                let response;
                try {
                    // Try variable font format first (most efficient)
                    response = await fetch(`https://fonts.googleapis.com/css2?family=${fontNameUrl}:ital,wght@0,100..900;1,100..900&display=swap`);
                } catch (error) {
                    console.log('Variable font request failed, trying comprehensive format');
                    // Fallback to comprehensive individual weights format
                    response = await fetch(`https://fonts.googleapis.com/css2?family=${fontNameUrl}:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`);
                }
                
                if (!response.ok) {
                    throw new Error('Failed to fetch font CSS');
                }

                const fontCSS = await response.text();
                
                // Simple and reliable extraction: get all @font-face rules from the CSS
                console.log('Starting CSS extraction for:', fontName);
                console.log('Full CSS length:', fontCSS.length);
                
                const ruleMatches = fontCSS.match(/@font-face[^}]+}/g);
                
                console.log('Total @font-face rules found:', ruleMatches ? ruleMatches.length : 0);
                
                let fontFaceRulesText = '';
                
                if (ruleMatches && ruleMatches.length > 0) {
                    // Filter to only include latin subset rules
                    const latinRules = ruleMatches.filter(rule => {
                        // Check if this rule is likely part of latin subset
                        // (Google Fonts puts latin rules after /* latin */ comment)
                        const isLatin = rule.includes('unicode-range') && 
                                      (rule.includes('U+0000-00FF') || rule.includes('U+0041-007A'));
                        if (isLatin) {
                            console.log('Found latin rule:', rule.substring(0, 100) + '...');
                        }
                        return isLatin;
                    });
                    
                    console.log('Latin rules found:', latinRules.length);
                    
                    if (latinRules.length > 0) {
                        fontFaceRulesText = latinRules.join('\n\n');
                    } else {
                        // Fallback: use all rules if we can't filter properly
                        console.log('No latin rules found, using all rules');
                        fontFaceRulesText = ruleMatches.join('\n\n');
                    }
                } else {
                    // If no @font-face rules found, try the original method
                    console.log('No @font-face rules found with regex, trying alternative method');
                    const latinSection = fontCSS.split('/* latin */')[1];
                    if (latinSection) {
                        const nextSubset = latinSection.split('/* ')[0];
                        const ruleMatchesFallback = nextSubset.match(/@font-face[^}]+}/g);
                        fontFaceRulesText = ruleMatchesFallback ? ruleMatchesFallback.join('\n\n') : '';
                        console.log('Fallback rules found:', ruleMatchesFallback ? ruleMatchesFallback.length : 0);
                    } else {
                        throw new Error('No @font-face rules found in font CSS');
                    }
                }

                if (fontFaceRulesText) {
                    // Check if we can optimize for variable fonts
                    const hasVariableFont = fontFaceRulesText.includes('font-weight: 100 900');
                    
                    let optimizedRules = fontFaceRulesText;
                    
                    // For variable fonts, we can often consolidate multiple weight rules
                    if (hasVariableFont) {
                        // Keep only the variable font rules and remove individual weight rules
                        const lines = fontFaceRulesText.split('\n');
                        const filteredLines = [];
                        let inVariableRule = false;
                        let currentFontStyle = '';
                        
                        for (const line of lines) {
                            if (line.includes('@font-face')) {
                                // Start of a new rule - check if it's a variable font
                                if (line.includes('font-weight: 100 900')) {
                                    inVariableRule = true;
                                    filteredLines.push(line);
                                } else {
                                    inVariableRule = false;
                                }
                            } else if (inVariableRule) {
                                filteredLines.push(line);
                                if (line.includes('}')) {
                                    inVariableRule = false;
                                }
                            }
                        }
                        
                        // If we found variable fonts, use them
                        if (filteredLines.length > 0) {
                            optimizedRules = filteredLines.join('\n');
                        }
                    }
                    
                    // Create comprehensive CSS with the actual @font-face rules
                    const css = `
/* ${fontName} - ${category} */
/* üéØ EXCLUSIVE: Latin subset @font-face rules from Google Fonts */
/* Note: Some fonts use individual weight files, others use variable fonts */
/* Includes ALL available weights and style variants from Google Fonts */
/* No Cyrillic, Greek, Latin-Ext, or other subsets included */
${optimizedRules}

/* üìã CSS Usage Examples */
.${fontNameKebab}-regular {
    font-family: '${fontName}', ${category};
    font-weight: 400;
}

.${fontNameKebab}-bold {
    font-family: '${fontName}', ${category};
    font-weight: 700;
}

/* üí° CSS Variables (optional) */
:root {
    --font-${fontNameKebab}: "${fontName}", ${category};
}

.${fontNameKebab} {
    font-family: var(--font-${fontNameKebab});
}

/* üé® Usage Examples:
   <div class="${fontNameKebab}-regular">Regular text</div>
   <div class="${fontNameKebab}-bold">Bold text</div>
   <div class="${fontNameKebab}" style="font-weight: 400;">Using CSS variable</div>
*/

/* ‚ö†Ô∏è  Note: These are the actual @font-face rules from Google Fonts.
   The URLs point to the real font files hosted on Google's CDN.
   For self-hosting, you would need to download these font files.
*/
                    `;

                    navigator.clipboard.writeText(css).then(() => {
                        alert(`‚úÖ CSS for ${fontName} copied to clipboard! Check console for debug details.`);
                    }).catch(err => {
                        console.error('Failed to copy CSS:', err);
                        alert('Failed to copy CSS. Please try again.');
                    });
                } else {
                    // Fallback to the original method if extraction fails
                    const fallbackCSS = `
/* ${fontName} - ${category} */
/* Fallback: Use Google Fonts CDN */
<link href="https://fonts.googleapis.com/css2?family=${fontNameUrl}:wght@400;700&display=swap" rel="stylesheet">

.${fontNameKebab}-regular {
    font-family: '${fontName}', ${category};
    font-weight: 400;
}

.${fontNameKebab}-bold {
    font-family: '${fontName}', ${category};
    font-weight: 700;
}
                    `;

                    navigator.clipboard.writeText(fallbackCSS).then(() => {
                        alert(`‚ö†Ô∏è Copied fallback CSS for ${fontName}. Could not extract @font-face rules.`);
                    });
                }
            } catch (error) {
                console.error('Error copying CSS:', error);
                
                // Fallback to simple CSS if API call fails
                const simpleCSS = `
/* ${fontName} - ${category} */
<link href="https://fonts.googleapis.com/css2?family=${fontNameUrl}:wght@400;700&display=swap" rel="stylesheet">

.${fontNameKebab} {
    font-family: '${fontName}', ${category};
}
                `;

                navigator.clipboard.writeText(simpleCSS).then(() => {
                    alert(`‚ö†Ô∏è Copied simple CSS for ${fontName}. Full @font-face rules unavailable.`);
                });
            }
        }

        function viewOnGoogle(fontName) {
            window.open(`https://fonts.google.com/specimen/${fontName.replace(/ /g, '+')}`, '_blank');
        }

        // Load favorites from localStorage
        function loadFavorites() {
            const savedFavorites = localStorage.getItem('favoriteFonts');
            if (savedFavorites) {
                try {
                    const parsed = JSON.parse(savedFavorites);
                    if (Array.isArray(parsed)) {
                        parsed.forEach(fontName => favorites.add(fontName));
                        console.log('Loaded ' + favorites.size + ' favorites');
                        
                        // Update heart icons to reflect loaded favorites
                        updateFavoriteHearts();
                    }
                } catch (e) {
                    console.error('Error loading favorites:', e);
                }
            } else {
                console.log('No favorites found in localStorage');
            }
        }
        
        function updateFavoriteHearts() {
            // Update all heart icons based on current favorites
            const heartIcons = document.querySelectorAll('.favorite-heart');
            heartIcons.forEach(heart => {
                const fontName = heart.dataset.fontName;
                if (favorites.has(fontName)) {
                    heart.classList.add('favorited');
                } else {
                    heart.classList.remove('favorited');
                }
            });
        }
        
        // Save favorites to localStorage
        function saveFavorites() {
            const favoritesArray = Array.from(favorites);
            localStorage.setItem('favoriteFonts', JSON.stringify(favoritesArray));
        }
        
        // Start the app
        init();
        loadFavorites();
        loadThemePreference();
        
        // Force show favorites button for testing (remove this later)
        setTimeout(() => {
            const favoritesBtn = document.querySelector('.category-btn[data-category="favorites"]');
            if (favoritesBtn) {
                favoritesBtn.style.display = 'inline-block';
            }
        }, 100);
    </script>
</body></html>
